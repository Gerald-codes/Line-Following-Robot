// test_ir_classification.c
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "ir_sensor.h"

// ===== MOCKS / STUBS FOR HARDWARE =====

// Mocks for ADC and GPIO used by ir_sensor.c
// We only need enough to satisfy the linker and drive controlled values.

static uint16_t mock_line_adc = 0;
static uint16_t mock_barcode_adc = 0;
static bool     mock_gpio_pin6_state = false;

// adc_* stubs
void adc_init(void) {}
void adc_gpio_init(uint gpio) {}
void adc_select_input(uint input) {
    // do nothing; selection is ignored, we return from our mocks
}
uint16_t adc_read(void) {
    // ir_read_line_sensor() and ir_read_barcode_sensor() both call adc_read()
    // We distinguish by which wrapper called us, so for this simple test
    // we expose them directly via ir_read_* mocks below instead.
    return 0;
}

// gpio_* stubs
void gpio_init(uint gpio) {}
void gpio_set_dir(uint gpio, bool out) {}
bool gpio_get(uint gpio) {
    // Only used for BARCODE_SENSOR_PIN (6)
    (void)gpio;
    return mock_gpio_pin6_state;
}

// time / sleep stubs (for functions that use them, but here they won't really be used)
uint32_t to_ms_since_boot(absolute_time_t t) { (void)t; return 0; }
absolute_time_t get_absolute_time(void) { absolute_time_t t; return t; }
void sleep_ms(uint32_t ms) { (void)ms; }

// Override ir_read_* so they use our mock ADC values
uint16_t ir_read_line_sensor(void) {
    return mock_line_adc;
}
uint16_t ir_read_barcode_sensor(void) {
    return mock_barcode_adc;
}

// ===== SIMPLE ASSERT MACRO =====
#define ASSERT_TRUE(cond, msg) \
    do { if (!(cond)) { printf("  FAIL: %s\n", msg); return 1; } \
         else { printf("  PASS: %s\n", msg); } } while(0)

int main(void) {
    printf("=== UT-IR-001: IR classification (line & barcode) ===\n");

    // Use your default calibration values from ir_sensor.c
    // white_value = 2600, black_value = 150, line_threshold = (white+black)/2

    // 1) Line sensor: far from threshold → not "on edge"
    //   white side: reading much lower than threshold (inverted: white is LOW)
    mock_line_adc = 100;   // close to black_value? Wait: your comments say inverted but thresholds say black=HIGH.
    // For safety: choose values relative to current threshold from code.
    // However, ir_line_detected() uses abs(reading - threshold) < tolerance,
    // so we can just test "near" vs "far".

    // Get current threshold via API
    uint16_t thr = ir_get_threshold();
    uint16_t white = ir_get_white_value();
    uint16_t black = ir_get_black_value();

    printf("  Using white=%u, black=%u, threshold=%u\n", white, black, thr);

    // 1) Reading far from threshold → not on edge
    mock_line_adc = white;  // far side
    ASSERT_TRUE(!ir_line_detected(), "Line sensor on pure white: not on edge");

    // 2) Reading close to threshold → on edge
    // pick value near threshold
    mock_line_adc = thr;
    ASSERT_TRUE(ir_line_detected(), "Line sensor near threshold: on edge");

    // 3) Barcode digital: assume LOW = black (your code uses !gpio_get)
    mock_gpio_pin6_state = true;   // HIGH at pin -> !HIGH = false -> no black
    ASSERT_TRUE(!ir_barcode_digital_detected(), "Barcode pin HIGH: no black detected");

    mock_gpio_pin6_state = false;  // LOW at pin -> !LOW = true -> black
    ASSERT_TRUE(ir_barcode_digital_detected(), "Barcode pin LOW: black detected");

    printf("UT-IR-001 COMPLETED\n");
    return 0;
}
